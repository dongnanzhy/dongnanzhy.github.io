<!DOCTYPE html>
<html>
  <head><meta name="generator" content="Hexo 3.8.0">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="Yan&#39;s git io">
  <meta name="keyword" content="YAN&#39;s BLOG">
  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      transformer | YAN&#39;s BLOG
    
  </title>
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/plugins/gitment.css">
  <script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdn.bootcss.com/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>
  <script src="/js/qrious.js"></script>
<script src="/js/gitment.js"></script>
  
  
    <!-- MathJax support START -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <!-- MathJax support END -->
  


</head>
<div class="wechat-share">
  <img src="/css/images/logo.png">
</div>

  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>YAN's BLOG</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">Tags</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/archives/" class="item-link">Archives</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/project/" class="item-link">Projects</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">About</a>
          
        </li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">Tags</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/archives/" class="menu-link">Archives</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/project/" class="menu-link">Projects</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">About</a>
            
          </li>
        
      </ul>
    </div>
  </div>
</header>

    <div id="article-banner">
  <h2>transformer</h2>
  <p class="post-date">2019-05-26</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><h5 id="Copyright-2019-The-TensorFlow-Authors"><a href="#Copyright-2019-The-TensorFlow-Authors" class="headerlink" title="Copyright 2019 The TensorFlow Authors."></a>Copyright 2019 The TensorFlow Authors.</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#@title Licensed under the Apache License, Version 2.0 (the "License");</span></span><br><span class="line"><span class="comment"># you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment"># You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># https://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"># distributed under the License is distributed on an "AS IS" BASIS,</span></span><br><span class="line"><span class="comment"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"># See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"># limitations under the License.</span></span><br></pre></td></tr></table></figure>
<h1 id="Transformer-model-for-language-understanding"><a href="#Transformer-model-for-language-understanding" class="headerlink" title="Transformer model for language understanding"></a>Transformer model for language understanding</h1><table class="tfo-notebook-buttons" align="left"><br>  <td><br>    <a target="_blank" href="https://www.tensorflow.org/alpha/tutorials/sequences/transformer"><br>    <img src="https://www.tensorflow.org/images/tf_logo_32px.png"><br>    View on TensorFlow.org</a><br>  </td><br>  <td><br>    <a target="_blank" href="https://colab.research.google.com/github/tensorflow/docs/blob/master/site/en/r2/tutorials/sequences/transformer.ipynb"><br>    <img src="https://www.tensorflow.org/images/colab_logo_32px.png"><br>    Run in Google Colab</a><br>  </td><br>  <td><br>    <a target="_blank" href="https://github.com/tensorflow/docs/blob/master/site/en/r2/tutorials/sequences/transformer.ipynb"><br>    <img src="https://www.tensorflow.org/images/GitHub-Mark-32px.png"><br>    View source on GitHub</a><br>  </td><br></table>

<p>This tutorial trains a <a href="https://arxiv.org/abs/1706.03762" class="external" target="_blank" rel="noopener">Transformer model</a> to translate Portuguese to English. This is an advanced example that assumes knowledge of <a href="text_generation.ipynb">text generation</a> and <a href="nmt_with_attention.ipynb">attention</a>.</p>
<p>The core idea behind the Transformer model is <em>self-attention</em>â€”the ability to attend to different positions of the input sequence to compute a representation of that sequence. Transformer creates stacks of self-attention layers and is explained below in the sections <em>Scaled dot product attention</em> and <em>Multi-head attention</em>.</p>
<p>A transformer model handles variable-sized input using stacks of self-attention layers instead of <a href="text_classification_rnn.ipynb">RNNs</a> or <a href="../images/intro_to_cnns.ipynb">CNNs</a>. This general architecture has a number of advantages:</p>
<ul>
<li>It make no assumptions about the temporal/spatial relationships across the data. This is ideal for processing a set of objects (for example, <a href="https://deepmind.com/blog/alphastar-mastering-real-time-strategy-game-starcraft-ii/#block-8" target="_blank" rel="noopener">StarCraft units</a>).</li>
<li>Layer outputs can be calculated in parallel, instead of a series like an RNN.</li>
<li>Distant items can affect each otherâ€™s output without passing through many RNN-steps, or convolution layers (see <a href="https://arxiv.org/pdf/1903.03878.pdf" target="_blank" rel="noopener">Scene Memory Transformer</a> for example).</li>
<li>It can learn long-range dependencies. This is a challenge in many sequence tasks.</li>
</ul>
<p>The downsides of this architecture are:</p>
<ul>
<li>For a time-series, the output for a time-step is calculated from the <em>entire history</em> instead of only the inputs and current hidden-state. This <em>may</em> be less efficient.   </li>
<li>If the input <em>does</em> have a  temporal/spatial relationship, like text, some positional encoding must be added or the model will effectively see a bag of words. </li>
</ul>
<p>After training the model in this notebook, you will be able to input a Portuguese sentence and return the English translation.</p>
<p><img src="https://www.tensorflow.org/images/tutorials/transformer/attention_map_portuguese.png" width="800" alt="Attention heatmap"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> absolute_import, division, print_function, unicode_literals</span><br><span class="line"></span><br><span class="line"><span class="comment"># !pip install tf-nightly-gpu-2.0-preview</span></span><br><span class="line"><span class="keyword">import</span> tensorflow_datasets <span class="keyword">as</span> tfds</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure>
<pre><code>/home/dongnanzhy/miniconda3/lib/python3.6/site-packages/h5py/__init__.py:36: FutureWarning: Conversion of the second argument of issubdtype from `float` to `np.floating` is deprecated. In future, it will be treated as `np.float64 == np.dtype(float).type`.
  from ._conv import register_converters as _register_converters
</code></pre><h2 id="Setup-input-pipeline"><a href="#Setup-input-pipeline" class="headerlink" title="Setup input pipeline"></a>Setup input pipeline</h2><p>Use <a href="https://www.tensorflow.org/datasets" target="_blank" rel="noopener">TFDS</a> to load the <a href="https://github.com/neulab/word-embeddings-for-nmt" target="_blank" rel="noopener">Portugese-English translation dataset</a> from the <a href="https://www.ted.com/participate/translate" target="_blank" rel="noopener">TED Talks Open Translation Project</a>.</p>
<p>This dataset contains approximately 50000 training examples, 1100 validation examples, and 2000 test examples.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">examples, metadata = tfds.load(<span class="string">'ted_hrlr_translate/pt_to_en'</span>, with_info=<span class="keyword">True</span>,</span><br><span class="line">                               as_supervised=<span class="keyword">True</span>)</span><br><span class="line">train_examples, val_examples = examples[<span class="string">'train'</span>], examples[<span class="string">'validation'</span>]</span><br></pre></td></tr></table></figure>
<pre><code>[1mDownloading and preparing dataset ted_hrlr_translate (124.94 MiB) to /home/dongnanzhy/tensorflow_datasets/ted_hrlr_translate/pt_to_en/0.0.1...[0m
</code></pre><p>Failed to display Jupyter Widget of type <code>HBox</code>.</p><br><p><br>  If youâ€™re reading this message in the Jupyter Notebook or JupyterLab Notebook, it may mean<br>  that the widgets JavaScript is still loading. If this message persists, it<br>  likely means that the widgets JavaScript library is either not installed or<br>  not enabled. See the <a href="https://ipywidgets.readthedocs.io/en/stable/user_install.html" target="_blank" rel="noopener">Jupyter<br>  Widgets Documentation</a> for setup instructions.<br></p><br><p><br>  If youâ€™re reading this message in another frontend (for example, a static<br>  rendering on GitHub or <a href="https://nbviewer.jupyter.org/" target="_blank" rel="noopener">NBViewer</a>),<br>  it may mean that your frontend doesnâ€™t currently support widgets.<br></p>




<p>Failed to display Jupyter Widget of type <code>HBox</code>.</p><br><p><br>  If youâ€™re reading this message in the Jupyter Notebook or JupyterLab Notebook, it may mean<br>  that the widgets JavaScript is still loading. If this message persists, it<br>  likely means that the widgets JavaScript library is either not installed or<br>  not enabled. See the <a href="https://ipywidgets.readthedocs.io/en/stable/user_install.html" target="_blank" rel="noopener">Jupyter<br>  Widgets Documentation</a> for setup instructions.<br></p><br><p><br>  If youâ€™re reading this message in another frontend (for example, a static<br>  rendering on GitHub or <a href="https://nbviewer.jupyter.org/" target="_blank" rel="noopener">NBViewer</a>),<br>  it may mean that your frontend doesnâ€™t currently support widgets.<br></p>




<p>Failed to display Jupyter Widget of type <code>HBox</code>.</p><br><p><br>  If youâ€™re reading this message in the Jupyter Notebook or JupyterLab Notebook, it may mean<br>  that the widgets JavaScript is still loading. If this message persists, it<br>  likely means that the widgets JavaScript library is either not installed or<br>  not enabled. See the <a href="https://ipywidgets.readthedocs.io/en/stable/user_install.html" target="_blank" rel="noopener">Jupyter<br>  Widgets Documentation</a> for setup instructions.<br></p><br><p><br>  If youâ€™re reading this message in another frontend (for example, a static<br>  rendering on GitHub or <a href="https://nbviewer.jupyter.org/" target="_blank" rel="noopener">NBViewer</a>),<br>  it may mean that your frontend doesnâ€™t currently support widgets.<br></p>










<p>Failed to display Jupyter Widget of type <code>HBox</code>.</p><br><p><br>  If youâ€™re reading this message in the Jupyter Notebook or JupyterLab Notebook, it may mean<br>  that the widgets JavaScript is still loading. If this message persists, it<br>  likely means that the widgets JavaScript library is either not installed or<br>  not enabled. See the <a href="https://ipywidgets.readthedocs.io/en/stable/user_install.html" target="_blank" rel="noopener">Jupyter<br>  Widgets Documentation</a> for setup instructions.<br></p><br><p><br>  If youâ€™re reading this message in another frontend (for example, a static<br>  rendering on GitHub or <a href="https://nbviewer.jupyter.org/" target="_blank" rel="noopener">NBViewer</a>),<br>  it may mean that your frontend doesnâ€™t currently support widgets.<br></p>






<p>Failed to display Jupyter Widget of type <code>HBox</code>.</p><br><p><br>  If youâ€™re reading this message in the Jupyter Notebook or JupyterLab Notebook, it may mean<br>  that the widgets JavaScript is still loading. If this message persists, it<br>  likely means that the widgets JavaScript library is either not installed or<br>  not enabled. See the <a href="https://ipywidgets.readthedocs.io/en/stable/user_install.html" target="_blank" rel="noopener">Jupyter<br>  Widgets Documentation</a> for setup instructions.<br></p><br><p><br>  If youâ€™re reading this message in another frontend (for example, a static<br>  rendering on GitHub or <a href="https://nbviewer.jupyter.org/" target="_blank" rel="noopener">NBViewer</a>),<br>  it may mean that your frontend doesnâ€™t currently support widgets.<br></p>



<pre><code>WARNING: Logging before flag parsing goes to stderr.
W0525 16:13:27.155797 140479363516160 deprecation.py:323] From /home/dongnanzhy/miniconda3/lib/python3.6/site-packages/tensorflow_datasets/core/file_format_adapter.py:247: tf_record_iterator (from tensorflow.python.lib.io.tf_record) is deprecated and will be removed in a future version.
Instructions for updating:
Use eager execution and: 
`tf.data.TFRecordDataset(path)`
</code></pre><p>Failed to display Jupyter Widget of type <code>HBox</code>.</p><br><p><br>  If youâ€™re reading this message in the Jupyter Notebook or JupyterLab Notebook, it may mean<br>  that the widgets JavaScript is still loading. If this message persists, it<br>  likely means that the widgets JavaScript library is either not installed or<br>  not enabled. See the <a href="https://ipywidgets.readthedocs.io/en/stable/user_install.html" target="_blank" rel="noopener">Jupyter<br>  Widgets Documentation</a> for setup instructions.<br></p><br><p><br>  If youâ€™re reading this message in another frontend (for example, a static<br>  rendering on GitHub or <a href="https://nbviewer.jupyter.org/" target="_blank" rel="noopener">NBViewer</a>),<br>  it may mean that your frontend doesnâ€™t currently support widgets.<br></p>




<p>Failed to display Jupyter Widget of type <code>HBox</code>.</p><br><p><br>  If youâ€™re reading this message in the Jupyter Notebook or JupyterLab Notebook, it may mean<br>  that the widgets JavaScript is still loading. If this message persists, it<br>  likely means that the widgets JavaScript library is either not installed or<br>  not enabled. See the <a href="https://ipywidgets.readthedocs.io/en/stable/user_install.html" target="_blank" rel="noopener">Jupyter<br>  Widgets Documentation</a> for setup instructions.<br></p><br><p><br>  If youâ€™re reading this message in another frontend (for example, a static<br>  rendering on GitHub or <a href="https://nbviewer.jupyter.org/" target="_blank" rel="noopener">NBViewer</a>),<br>  it may mean that your frontend doesnâ€™t currently support widgets.<br></p>






<p>Failed to display Jupyter Widget of type <code>HBox</code>.</p><br><p><br>  If youâ€™re reading this message in the Jupyter Notebook or JupyterLab Notebook, it may mean<br>  that the widgets JavaScript is still loading. If this message persists, it<br>  likely means that the widgets JavaScript library is either not installed or<br>  not enabled. See the <a href="https://ipywidgets.readthedocs.io/en/stable/user_install.html" target="_blank" rel="noopener">Jupyter<br>  Widgets Documentation</a> for setup instructions.<br></p><br><p><br>  If youâ€™re reading this message in another frontend (for example, a static<br>  rendering on GitHub or <a href="https://nbviewer.jupyter.org/" target="_blank" rel="noopener">NBViewer</a>),<br>  it may mean that your frontend doesnâ€™t currently support widgets.<br></p>






<p>Failed to display Jupyter Widget of type <code>HBox</code>.</p><br><p><br>  If youâ€™re reading this message in the Jupyter Notebook or JupyterLab Notebook, it may mean<br>  that the widgets JavaScript is still loading. If this message persists, it<br>  likely means that the widgets JavaScript library is either not installed or<br>  not enabled. See the <a href="https://ipywidgets.readthedocs.io/en/stable/user_install.html" target="_blank" rel="noopener">Jupyter<br>  Widgets Documentation</a> for setup instructions.<br></p><br><p><br>  If youâ€™re reading this message in another frontend (for example, a static<br>  rendering on GitHub or <a href="https://nbviewer.jupyter.org/" target="_blank" rel="noopener">NBViewer</a>),<br>  it may mean that your frontend doesnâ€™t currently support widgets.<br></p>




<p>Failed to display Jupyter Widget of type <code>HBox</code>.</p><br><p><br>  If youâ€™re reading this message in the Jupyter Notebook or JupyterLab Notebook, it may mean<br>  that the widgets JavaScript is still loading. If this message persists, it<br>  likely means that the widgets JavaScript library is either not installed or<br>  not enabled. See the <a href="https://ipywidgets.readthedocs.io/en/stable/user_install.html" target="_blank" rel="noopener">Jupyter<br>  Widgets Documentation</a> for setup instructions.<br></p><br><p><br>  If youâ€™re reading this message in another frontend (for example, a static<br>  rendering on GitHub or <a href="https://nbviewer.jupyter.org/" target="_blank" rel="noopener">NBViewer</a>),<br>  it may mean that your frontend doesnâ€™t currently support widgets.<br></p>




<p>Failed to display Jupyter Widget of type <code>HBox</code>.</p><br><p><br>  If youâ€™re reading this message in the Jupyter Notebook or JupyterLab Notebook, it may mean<br>  that the widgets JavaScript is still loading. If this message persists, it<br>  likely means that the widgets JavaScript library is either not installed or<br>  not enabled. See the <a href="https://ipywidgets.readthedocs.io/en/stable/user_install.html" target="_blank" rel="noopener">Jupyter<br>  Widgets Documentation</a> for setup instructions.<br></p><br><p><br>  If youâ€™re reading this message in another frontend (for example, a static<br>  rendering on GitHub or <a href="https://nbviewer.jupyter.org/" target="_blank" rel="noopener">NBViewer</a>),<br>  it may mean that your frontend doesnâ€™t currently support widgets.<br></p>






<p>Failed to display Jupyter Widget of type <code>HBox</code>.</p><br><p><br>  If youâ€™re reading this message in the Jupyter Notebook or JupyterLab Notebook, it may mean<br>  that the widgets JavaScript is still loading. If this message persists, it<br>  likely means that the widgets JavaScript library is either not installed or<br>  not enabled. See the <a href="https://ipywidgets.readthedocs.io/en/stable/user_install.html" target="_blank" rel="noopener">Jupyter<br>  Widgets Documentation</a> for setup instructions.<br></p><br><p><br>  If youâ€™re reading this message in another frontend (for example, a static<br>  rendering on GitHub or <a href="https://nbviewer.jupyter.org/" target="_blank" rel="noopener">NBViewer</a>),<br>  it may mean that your frontend doesnâ€™t currently support widgets.<br></p>






<p>Failed to display Jupyter Widget of type <code>HBox</code>.</p><br><p><br>  If youâ€™re reading this message in the Jupyter Notebook or JupyterLab Notebook, it may mean<br>  that the widgets JavaScript is still loading. If this message persists, it<br>  likely means that the widgets JavaScript library is either not installed or<br>  not enabled. See the <a href="https://ipywidgets.readthedocs.io/en/stable/user_install.html" target="_blank" rel="noopener">Jupyter<br>  Widgets Documentation</a> for setup instructions.<br></p><br><p><br>  If youâ€™re reading this message in another frontend (for example, a static<br>  rendering on GitHub or <a href="https://nbviewer.jupyter.org/" target="_blank" rel="noopener">NBViewer</a>),<br>  it may mean that your frontend doesnâ€™t currently support widgets.<br></p>




<p>Failed to display Jupyter Widget of type <code>HBox</code>.</p><br><p><br>  If youâ€™re reading this message in the Jupyter Notebook or JupyterLab Notebook, it may mean<br>  that the widgets JavaScript is still loading. If this message persists, it<br>  likely means that the widgets JavaScript library is either not installed or<br>  not enabled. See the <a href="https://ipywidgets.readthedocs.io/en/stable/user_install.html" target="_blank" rel="noopener">Jupyter<br>  Widgets Documentation</a> for setup instructions.<br></p><br><p><br>  If youâ€™re reading this message in another frontend (for example, a static<br>  rendering on GitHub or <a href="https://nbviewer.jupyter.org/" target="_blank" rel="noopener">NBViewer</a>),<br>  it may mean that your frontend doesnâ€™t currently support widgets.<br></p>




<p>Failed to display Jupyter Widget of type <code>HBox</code>.</p><br><p><br>  If youâ€™re reading this message in the Jupyter Notebook or JupyterLab Notebook, it may mean<br>  that the widgets JavaScript is still loading. If this message persists, it<br>  likely means that the widgets JavaScript library is either not installed or<br>  not enabled. See the <a href="https://ipywidgets.readthedocs.io/en/stable/user_install.html" target="_blank" rel="noopener">Jupyter<br>  Widgets Documentation</a> for setup instructions.<br></p><br><p><br>  If youâ€™re reading this message in another frontend (for example, a static<br>  rendering on GitHub or <a href="https://nbviewer.jupyter.org/" target="_blank" rel="noopener">NBViewer</a>),<br>  it may mean that your frontend doesnâ€™t currently support widgets.<br></p>



<pre><code>[1mDataset ted_hrlr_translate downloaded and prepared to /home/dongnanzhy/tensorflow_datasets/ted_hrlr_translate/pt_to_en/0.0.1. Subsequent calls will reuse this data.[0m
</code></pre><p>Create a custom subwords tokenizer from the training dataset. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> pt, en <span class="keyword">in</span> train_examples:</span><br><span class="line">    print(pt)</span><br><span class="line">    print(en)</span><br><span class="line">    print(en.numpy())</span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<pre><code>tf.Tensor(b&apos;agora aqui temos imagens sendo extra\xc3\xaddas em tempo real diretamente do feed ,&apos;, shape=(), dtype=string)
tf.Tensor(b&apos;now here are live images being pulled straight from the feed .&apos;, shape=(), dtype=string)
b&apos;now here are live images being pulled straight from the feed .&apos;
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tokenizer_en = tfds.features.text.SubwordTextEncoder.build_from_corpus(</span><br><span class="line">    (en.numpy() <span class="keyword">for</span> pt, en <span class="keyword">in</span> train_examples), target_vocab_size=<span class="number">2</span>**<span class="number">13</span>)</span><br><span class="line"></span><br><span class="line">tokenizer_pt = tfds.features.text.SubwordTextEncoder.build_from_corpus(</span><br><span class="line">    (pt.numpy() <span class="keyword">for</span> pt, en <span class="keyword">in</span> train_examples), target_vocab_size=<span class="number">2</span>**<span class="number">13</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sample_string = <span class="string">'Transformer is awesome.'</span></span><br><span class="line"></span><br><span class="line">tokenized_string = tokenizer_en.encode(sample_string)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">'Tokenized string is &#123;&#125;'</span>.format(tokenized_string))</span><br><span class="line"></span><br><span class="line">original_string = tokenizer_en.decode(tokenized_string)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">'The original string: &#123;&#125;'</span>.format(original_string))</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> original_string == sample_string</span><br></pre></td></tr></table></figure>
<pre><code>Tokenized string is [7915, 1248, 7946, 7194, 13, 2799, 7877]
The original string: Transformer is awesome.
</code></pre><p>The tokenizer encodes the string by breaking it into subwords if the word is not in its dictionary.</p>
<p><strong>Tensforflow Tokenizerè‡ªåŠ¨æŠŠä¸åœ¨vocabé‡Œé¢çš„è¯æŒ‰char levelåˆ†å¼€äº†ï¼Œç¡®ä¿æ‰€æœ‰tokenizeåçš„è¯éƒ½åœ¨vocabé‡Œ</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ts <span class="keyword">in</span> tokenized_string:</span><br><span class="line">  <span class="keyword">print</span> (<span class="string">'&#123;&#125; ----&gt; &#123;&#125;'</span>.format(ts, tokenizer_en.decode([ts])))</span><br></pre></td></tr></table></figure>
<pre><code>7915 ----&gt; T
1248 ----&gt; ran
7946 ----&gt; s
7194 ----&gt; former 
13 ----&gt; is 
2799 ----&gt; awesome
7877 ----&gt; .
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BUFFER_SIZE = <span class="number">20000</span></span><br><span class="line">BATCH_SIZE = <span class="number">64</span></span><br></pre></td></tr></table></figure>
<p>Add a start and end token to the input and target. </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encode</span><span class="params">(lang1, lang2)</span>:</span></span><br><span class="line">  <span class="comment"># vocabåŠ å…¥ 'start of sentence' and 'end of sentence'</span></span><br><span class="line">  <span class="comment"># lang1, lang2 is Tensor, use '.numpy()' to binary string</span></span><br><span class="line">  lang1 = [tokenizer_pt.vocab_size] + tokenizer_pt.encode(</span><br><span class="line">      lang1.numpy()) + [tokenizer_pt.vocab_size+<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">  lang2 = [tokenizer_en.vocab_size] + tokenizer_en.encode(</span><br><span class="line">      lang2.numpy()) + [tokenizer_en.vocab_size+<span class="number">1</span>]</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> lang1, lang2</span><br></pre></td></tr></table></figure>
<p>Note: To keep this example small and relatively fast, drop examples with a length of over 40 tokens.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MAX_LENGTH = <span class="number">40</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">filter_max_length</span><span class="params">(x, y, max_length=MAX_LENGTH)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> tf.logical_and(tf.size(x) &lt;= max_length,</span><br><span class="line">                        tf.size(y) &lt;= max_length)</span><br></pre></td></tr></table></figure>
<p><strong>Operations inside <code>.map()</code> run in graph mode and receive a graph tensor that do not have a numpy attribute.</strong> The <code>tokenizer</code> expects a string or Unicode symbol to encode it into integers. Hence, you need to run the encoding inside a <code>tf.py_function</code>, which receives an eager tensor having a numpy attribute that contains the string value.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tf_encode</span><span class="params">(pt, en)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> tf.py_function(encode, [pt, en], [tf.int64, tf.int64])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Train set</span></span><br><span class="line"><span class="comment"># string to integer(token id)</span></span><br><span class="line">train_dataset = train_examples.map(tf_encode)</span><br><span class="line"><span class="comment"># fileter by max length(40)</span></span><br><span class="line">train_dataset = train_dataset.filter(filter_max_length)</span><br><span class="line"><span class="comment"># cache the dataset to memory to get a speedup while reading from it.</span></span><br><span class="line">train_dataset = train_dataset.cache()</span><br><span class="line">train_dataset = train_dataset.shuffle(BUFFER_SIZE).padded_batch(</span><br><span class="line">    BATCH_SIZE, padded_shapes=([<span class="number">-1</span>], [<span class="number">-1</span>]))</span><br><span class="line">train_dataset = train_dataset.prefetch(tf.data.experimental.AUTOTUNE)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Validation set</span></span><br><span class="line">val_dataset = val_examples.map(tf_encode)</span><br><span class="line">val_dataset = val_dataset.filter(filter_max_length).padded_batch(</span><br><span class="line">    BATCH_SIZE, padded_shapes=([<span class="number">-1</span>], [<span class="number">-1</span>]))</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">de_batch, en_batch = next(iter(val_dataset))</span><br><span class="line">de_batch, en_batch</span><br></pre></td></tr></table></figure>
<pre><code>(&lt;tf.Tensor: id=311424, shape=(64, 40), dtype=int64, numpy=
 array([[8214, 1259,    5, ...,    0,    0,    0],
        [8214,  299,   13, ...,    0,    0,    0],
        [8214,   59,    8, ...,    0,    0,    0],
        ...,
        [8214,   95,    3, ...,    0,    0,    0],
        [8214, 5157,    1, ...,    0,    0,    0],
        [8214, 4479, 7990, ...,    0,    0,    0]])&gt;,
 &lt;tf.Tensor: id=311425, shape=(64, 40), dtype=int64, numpy=
 array([[8087,   18,   12, ...,    0,    0,    0],
        [8087,  634,   30, ...,    0,    0,    0],
        [8087,   16,   13, ...,    0,    0,    0],
        ...,
        [8087,   12,   20, ...,    0,    0,    0],
        [8087,   17, 4981, ...,    0,    0,    0],
        [8087,   12, 5453, ...,    0,    0,    0]])&gt;)
</code></pre><h2 id="Positional-encoding"><a href="#Positional-encoding" class="headerlink" title="Positional encoding"></a>Positional encoding</h2><p>Since this model doesnâ€™t contain any recurrence or convolution, <strong>positional encoding is added to give the model some information about the relative position of the words in the sentence.</strong></p>
<p>The positional encoding vector is added to the embedding vector. Embeddings represent a token in a d-dimensional space where tokens with similar meaning will be closer to each other. But the embeddings do not encode the relative position of words in a sentence. So after adding the positional encoding, words will be closer to each other based on the <strong>similarity of their meaning</strong> and <strong>their position in the sentence</strong>, in the d-dimensional space.</p>
<p>See the notebook on <a href="https://github.com/tensorflow/examples/blob/master/community/en/position_encoding.ipynb" target="_blank" rel="noopener">positional encoding</a> to learn more about it. The formula for calculating the positional encoding is as follows:</p>
<p>$$\Large{PE_{(pos, 2i)} = sin(pos / 10000^{2i / d_{model}})} $$<br>$$\Large{PE_{(pos, 2i+1)} = cos(pos / 10000^{2i / d_{model}})} $$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_angles</span><span class="params">(pos, i, d_model)</span>:</span></span><br><span class="line">  <span class="comment"># pos: å¥å­ä¸­çš„ä½ç½®</span></span><br><span class="line">  <span class="comment"># i: embedding ç¬¬ i ä½</span></span><br><span class="line">  <span class="comment"># d_model: embedding dimension</span></span><br><span class="line">  angle_rates = <span class="number">1</span> / np.power(<span class="number">10000</span>, (<span class="number">2</span> * (i//<span class="number">2</span>)) / np.float32(d_model))</span><br><span class="line">  <span class="keyword">return</span> pos * angle_rates</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">positional_encoding</span><span class="params">(position, d_model)</span>:</span></span><br><span class="line">  angle_rads = get_angles(np.arange(position)[:, np.newaxis],</span><br><span class="line">                          np.arange(d_model)[np.newaxis, :],</span><br><span class="line">                          d_model)</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># apply sin to even indices in the array; 2i</span></span><br><span class="line">  sines = np.sin(angle_rads[:, <span class="number">0</span>::<span class="number">2</span>])</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># apply cos to odd indices in the array; 2i+1</span></span><br><span class="line">  cosines = np.cos(angle_rads[:, <span class="number">1</span>::<span class="number">2</span>])</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># æ³¨æ„ï¼šè¿™é‡Œç›´æ¥æŠŠsineså’Œconsines concatåœ¨ä¸€èµ·ï¼Œå¹¶æ²¡æœ‰æŒ‰åŸå§‹iå¥‡å¶ç©¿æ’</span></span><br><span class="line">  pos_encoding = np.concatenate([sines, cosines], axis=<span class="number">-1</span>)</span><br><span class="line">  </span><br><span class="line">  pos_encoding = pos_encoding[np.newaxis, ...]</span><br><span class="line"></span><br><span class="line">  <span class="comment"># æ³¨æ„ï¼šè¿™é‡Œè¿”å›tensoré»˜è®¤batch=1ï¼Œ</span></span><br><span class="line">  <span class="comment">#      å› ä¸ºposition encodingä¸è¾“å…¥æ— å…³ï¼Œåç»­è®¡ç®—æ—¶åˆ©ç”¨broadcastç›¸åŠ ï¼Œä¿è¯batchæ¯ä¸ªinstanceéƒ½æœ‰position encoding</span></span><br><span class="line">  <span class="keyword">return</span> tf.cast(pos_encoding, dtype=tf.float32)  <span class="comment"># (1, seq_len, embedding_dim)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pos_encoding = positional_encoding(<span class="number">50</span>, <span class="number">512</span>)</span><br><span class="line"><span class="keyword">print</span> (pos_encoding.shape)</span><br><span class="line"></span><br><span class="line">plt.pcolormesh(pos_encoding[<span class="number">0</span>], cmap=<span class="string">'RdBu'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Depth'</span>)</span><br><span class="line">plt.xlim((<span class="number">0</span>, <span class="number">512</span>))</span><br><span class="line">plt.ylabel(<span class="string">'Position'</span>)</span><br><span class="line">plt.colorbar()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<pre><code>(1, 50, 512)
</code></pre><p><img src="/images/transformer/output_27_1.png" alt="png"></p>
<h2 id="Masking"><a href="#Masking" class="headerlink" title="Masking"></a>Masking</h2><p>Mask all the pad tokens in the batch of sequence. It ensures that the <strong>model does not treat padding as the input</strong>. The mask indicates where pad value <code>0</code> is present: it outputs a <code>1</code> at those locations, and a <code>0</code> otherwise. <strong>(1ä»£è¡¨è¢«maskæ‰ï¼Œ0ä»£è¡¨é€šè¿‡)</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_padding_mask</span><span class="params">(seq)</span>:</span></span><br><span class="line">  seq = tf.cast(tf.math.equal(seq, <span class="number">0</span>), tf.float32)</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># add extra dimensions so that we can add the padding</span></span><br><span class="line">  <span class="comment"># to the attention logits.</span></span><br><span class="line">  <span class="keyword">return</span> seq[:, tf.newaxis, tf.newaxis, :]  <span class="comment"># (batch_size, 1, 1, seq_len)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = tf.constant([[<span class="number">7</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>]])</span><br><span class="line">create_padding_mask(x)</span><br></pre></td></tr></table></figure>
<pre><code>&lt;tf.Tensor: id=311442, shape=(3, 1, 1, 5), dtype=float32, numpy=
array([[[[0., 0., 1., 1., 0.]]],


       [[[0., 0., 0., 1., 1.]]],


       [[[1., 1., 1., 0., 0.]]]], dtype=float32)&gt;
</code></pre><p>The look-ahead mask is used to mask the future tokens in a sequence. In other words, the mask indicates which entries should not be used.</p>
<p>This means that to predict the third word, only the first and second word will be used. Similarly to predict the fourth word, only the first, second and the third word will be used and so on.</p>
<p><strong>look-ahead mask ç¡®ä¿sequenceåªèƒ½çœ‹åˆ°ä¹‹å‰å‡ºç°çš„word ï¼ˆ1ä»£è¡¨è¢«maskæ‰ï¼Œ0ä»£è¡¨é€šè¿‡)</strong> </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_look_ahead_mask</span><span class="params">(size)</span>:</span></span><br><span class="line">  mask = <span class="number">1</span> - tf.linalg.band_part(tf.ones((size, size)), <span class="number">-1</span>, <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span> mask  <span class="comment"># (seq_len, seq_len)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = tf.random.uniform((<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">temp = create_look_ahead_mask(x.shape[<span class="number">1</span>])</span><br><span class="line">temp</span><br></pre></td></tr></table></figure>
<pre><code>&lt;tf.Tensor: id=311458, shape=(3, 3), dtype=float32, numpy=
array([[0., 1., 1.],
       [0., 0., 1.],
       [0., 0., 0.]], dtype=float32)&gt;
</code></pre><h1 id="Preprocessing-finished"><a href="#Preprocessing-finished" class="headerlink" title="Preprocessing finished"></a>Preprocessing finished</h1><hr>
<h2 id="Scaled-dot-product-attention"><a href="#Scaled-dot-product-attention" class="headerlink" title="Scaled dot product attention"></a>Scaled dot product attention</h2><p><img src="https://www.tensorflow.org/images/tutorials/transformer/scaled_attention.png" width="500" alt="scaled_dot_product_attention"></p>
<p>The attention function used by the transformer takes three inputs: Q (query), K (key), V (value). The equation used to calculate the attention weights is:</p>
<p>$$\Large{Attention(Q, K, V) = softmax_k(\frac{QK^T}{\sqrt{d_k}}) V} $$</p>
<p><strong>d_k ä»£è¡¨Kçš„dimensionï¼Œè¿™ä¹ˆåšå¯ä»¥ä¿è¯Qå’ŒKç›¸ä¹˜åä¾ç„¶ä¿ç•™var=1</strong>. The dot-product attention is scaled by a factor of square root of the depth. This is done because for large values of depth, the dot product grows large in magnitude pushing the softmax function where it has small gradients resulting in a very hard softmax. </p>
<p>For example, consider that <code>Q</code> and <code>K</code> have a mean of 0 and variance of 1. Their matrix multiplication will have a mean of 0 and variance of <code>dk</code>. Hence, <em>square root of <code>dk</code></em> is used for scaling (and not any other number) because the matmul of <code>Q</code> and <code>K</code> should have a mean of 0 and variance of 1, so that we get a gentler softmax.</p>
<p><strong>maskä¹˜ä»¥æ— ç©·å°ï¼Œ0æ²¡æœ‰å½±å“ï¼Œè¡¨ç¤ºé€šè¿‡ã€‚1å˜æˆæ— ç©·å°ï¼Œè®¡ç®—softmaxåå˜æˆ0ï¼Œè¡¨ç¤ºä¸é€šè¿‡.</strong> The mask is multiplied with <em>-1e9 (close to negative infinity).</em> This is done because the mask is summed with the scaled matrix multiplication of Q and K and is applied immediately before a softmax. The goal is to zero out these cells, and large negative inputs to softmax are near zero in the output.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scaled_dot_product_attention</span><span class="params">(q, k, v, mask)</span>:</span></span><br><span class="line">  <span class="string">"""Calculate the attention weights.</span></span><br><span class="line"><span class="string">  q, k, v must have matching leading dimensions.</span></span><br><span class="line"><span class="string">  The mask has different shapes depending on its type(padding or look ahead) </span></span><br><span class="line"><span class="string">  but it must be broadcastable for addition.</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  Args:</span></span><br><span class="line"><span class="string">    q: query shape == (..., seq_len_q, depth)</span></span><br><span class="line"><span class="string">    k: key shape == (..., seq_len_k, depth)</span></span><br><span class="line"><span class="string">    v: value shape == (..., seq_len_v, depth)</span></span><br><span class="line"><span class="string">    mask: Float tensor with shape broadcastable </span></span><br><span class="line"><span class="string">          to (..., seq_len_q, seq_len_k). Defaults to None.</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">  Returns:</span></span><br><span class="line"><span class="string">    output, attention_weights</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line"></span><br><span class="line">  matmul_qk = tf.matmul(q, k, transpose_b=<span class="keyword">True</span>)  <span class="comment"># (..., seq_len_q, seq_len_k)</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># scale matmul_qk</span></span><br><span class="line">  dk = tf.cast(tf.shape(k)[<span class="number">-1</span>], tf.float32)</span><br><span class="line">  scaled_attention_logits = matmul_qk / tf.math.sqrt(dk)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># add the mask to the scaled tensor. </span></span><br><span class="line">  <span class="comment"># (mask=1 means block, mask=0 means pass)</span></span><br><span class="line">  <span class="keyword">if</span> mask <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">    scaled_attention_logits += (mask * <span class="number">-1e9</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment"># æ³¨æ„ï¼šsoftmax is normalized on the last axis (seq_len_k) so that the scores</span></span><br><span class="line">  <span class="comment"># add up to 1.</span></span><br><span class="line">  attention_weights = tf.nn.softmax(scaled_attention_logits, axis=<span class="number">-1</span>)  <span class="comment"># (..., seq_len_q, seq_len_k)</span></span><br><span class="line"></span><br><span class="line">  output = tf.matmul(attention_weights, v)  <span class="comment"># (..., seq_len_v, depth)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> output, attention_weights</span><br></pre></td></tr></table></figure>
<p>As the softmax normalization is done on K, its values decide the amount of importance given to Q.</p>
<p>The output represents the multiplication of the attention weights and the V (value) vector. This ensures that the words we want to focus on are kept as is and the irrelevant words are flushed out.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_out</span><span class="params">(q, k, v)</span>:</span></span><br><span class="line">  temp_out, temp_attn = scaled_dot_product_attention(</span><br><span class="line">      q, k, v, <span class="keyword">None</span>)</span><br><span class="line">  <span class="keyword">print</span> (<span class="string">'Attention weights are:'</span>)</span><br><span class="line">  <span class="keyword">print</span> (temp_attn)</span><br><span class="line">  <span class="keyword">print</span> (<span class="string">'Output is:'</span>)</span><br><span class="line">  <span class="keyword">print</span> (temp_out)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">np.set_printoptions(suppress=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">temp_k = tf.constant([[<span class="number">10</span>,<span class="number">0</span>,<span class="number">0</span>],</span><br><span class="line">                      [<span class="number">0</span>,<span class="number">10</span>,<span class="number">0</span>],</span><br><span class="line">                      [<span class="number">0</span>,<span class="number">0</span>,<span class="number">10</span>],</span><br><span class="line">                      [<span class="number">0</span>,<span class="number">0</span>,<span class="number">10</span>]], dtype=tf.float32)  <span class="comment"># (4, 3)</span></span><br><span class="line"></span><br><span class="line">temp_v = tf.constant([[   <span class="number">1</span>,<span class="number">0</span>],</span><br><span class="line">                      [  <span class="number">10</span>,<span class="number">0</span>],</span><br><span class="line">                      [ <span class="number">100</span>,<span class="number">5</span>],</span><br><span class="line">                      [<span class="number">1000</span>,<span class="number">6</span>]], dtype=tf.float32)  <span class="comment"># (4, 2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># This `query` aligns with the second `key`, query=Key[1:]</span></span><br><span class="line"><span class="comment"># so the second `value` is returned.</span></span><br><span class="line">temp_q = tf.constant([[<span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>]], dtype=tf.float32)  <span class="comment"># (1, 3)</span></span><br><span class="line">print_out(temp_q, temp_k, temp_v)</span><br></pre></td></tr></table></figure>
<pre><code>Attention weights are:
tf.Tensor([[0. 1. 0. 0.]], shape=(1, 4), dtype=float32)
Output is:
tf.Tensor([[10.  0.]], shape=(1, 2), dtype=float32)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This query aligns with a repeated key (third and fourth), </span></span><br><span class="line"><span class="comment"># so all associated values get averaged.</span></span><br><span class="line">temp_q = tf.constant([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>]], dtype=tf.float32)  <span class="comment"># (1, 3)</span></span><br><span class="line">print_out(temp_q, temp_k, temp_v)</span><br></pre></td></tr></table></figure>
<pre><code>Attention weights are:
tf.Tensor([[0.  0.  0.5 0.5]], shape=(1, 4), dtype=float32)
Output is:
tf.Tensor([[550.    5.5]], shape=(1, 2), dtype=float32)
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This query aligns equally with the first and second key, </span></span><br><span class="line"><span class="comment"># so their values get averaged.</span></span><br><span class="line">temp_q = tf.constant([[<span class="number">10</span>, <span class="number">10</span>, <span class="number">0</span>]], dtype=tf.float32)  <span class="comment"># (1, 3)</span></span><br><span class="line">print_out(temp_q, temp_k, temp_v)</span><br></pre></td></tr></table></figure>
<pre><code>Attention weights are:
tf.Tensor([[0.5 0.5 0.  0. ]], shape=(1, 4), dtype=float32)
Output is:
tf.Tensor([[5.5 0. ]], shape=(1, 2), dtype=float32)
</code></pre><p>Pass all the queries together.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">temp_q = tf.constant([[<span class="number">0</span>, <span class="number">10</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">10</span>], [<span class="number">10</span>, <span class="number">10</span>, <span class="number">0</span>]], dtype=tf.float32)  <span class="comment"># (3, 3)</span></span><br><span class="line">print_out(temp_q, temp_k, temp_v)</span><br></pre></td></tr></table></figure>
<pre><code>Attention weights are:
tf.Tensor(
[[0.  1.  0.  0. ]
 [0.  0.  0.5 0.5]
 [0.5 0.5 0.  0. ]], shape=(3, 4), dtype=float32)
Output is:
tf.Tensor(
[[ 10.    0. ]
 [550.    5.5]
 [  5.5   0. ]], shape=(3, 2), dtype=float32)
</code></pre><h2 id="Multi-head-attention"><a href="#Multi-head-attention" class="headerlink" title="Multi-head attention"></a>Multi-head attention</h2><p><img src="https://www.tensorflow.org/images/tutorials/transformer/multi_head_attention.png" width="500" alt="multi-head attention"></p>
<p>Multi-head attention consists of four parts:</p>
<ul>
<li>Linear layers and split into heads. (å…ˆæŠŠQ,K,Våˆ†æˆå‡ ä¸ªHeads)</li>
<li>Scaled dot-product attention. (æ¯ä¸ªHeadè®¡ç®—scaled dot-product attention)</li>
<li>Concatenation of heads. (concatæ¯ä¸ªHead attnç»“æœ)</li>
<li>Final linear layer. (å†è¿‡ä¸€å±‚FC[dimension ä¸å˜])</li>
</ul>
<p>Each multi-head attention block gets three inputs; Q (query), K (key), V (value). These are put through linear (Dense) layers and split up into multiple heads. </p>
<p>The <code>scaled_dot_product_attention</code> defined above is applied to each head (broadcasted for efficiency). An appropriate mask must be used in the attention step.  The attention output for each head is then concatenated (using <code>tf.transpose</code>, and <code>tf.reshape</code>) and put through a final <code>Dense</code> layer.</p>
<p>Instead of one single attention head, Q, K, and V are split into multiple heads because it allows the model to jointly attend to information at different positions from different representational spaces. After the split each head has a reduced dimensionality, so the total computation cost is the same as a single head attention with full dimensionality.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultiHeadAttention</span><span class="params">(tf.keras.layers.Layer)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, d_model, num_heads)</span>:</span></span><br><span class="line">    super(MultiHeadAttention, self).__init__()</span><br><span class="line">    self.num_heads = num_heads</span><br><span class="line">    self.d_model = d_model</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">assert</span> d_model % self.num_heads == <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    self.depth = d_model // self.num_heads</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># å®šä¹‰Q,K,Vçš„FC</span></span><br><span class="line">    self.wq = tf.keras.layers.Dense(d_model)</span><br><span class="line">    self.wk = tf.keras.layers.Dense(d_model)</span><br><span class="line">    self.wv = tf.keras.layers.Dense(d_model)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># å®šä¹‰æœ€åè¾“å‡ºçš„FC</span></span><br><span class="line">    self.dense = tf.keras.layers.Dense(d_model)</span><br><span class="line">        </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">split_heads</span><span class="params">(self, x, batch_size)</span>:</span></span><br><span class="line">    <span class="string">"""Split the last dimension into (num_heads, depth).</span></span><br><span class="line"><span class="string">    Transpose the result such that the shape is (batch_size, num_heads, seq_len, depth)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    x = tf.reshape(x, (batch_size, <span class="number">-1</span>, self.num_heads, self.depth))</span><br><span class="line">    <span class="keyword">return</span> tf.transpose(x, perm=[<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>])</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">call</span><span class="params">(self, v, k, q, mask)</span>:</span></span><br><span class="line">    batch_size = tf.shape(q)[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># step1: Q,K,V å…ˆè¿‡FC layer, åšlinear transform</span></span><br><span class="line">    q = self.wq(q)  <span class="comment"># (batch_size, seq_len, d_model)</span></span><br><span class="line">    k = self.wk(k)  <span class="comment"># (batch_size, seq_len, d_model)</span></span><br><span class="line">    v = self.wv(v)  <span class="comment"># (batch_size, seq_len, d_model)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># step2: æ ¹æ®å®šä¹‰çš„num_headsæ¥split Q,K,V</span></span><br><span class="line">    q = self.split_heads(q, batch_size)  <span class="comment"># (batch_size, num_heads, seq_len_q, depth)</span></span><br><span class="line">    k = self.split_heads(k, batch_size)  <span class="comment"># (batch_size, num_heads, seq_len_k, depth)</span></span><br><span class="line">    v = self.split_heads(v, batch_size)  <span class="comment"># (batch_size, num_heads, seq_len_v, depth)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># scaled_attention.shape == (batch_size, num_heads, seq_len_v, depth) [attention_output]</span></span><br><span class="line">    <span class="comment"># attention_weights.shape == (batch_size, num_heads, seq_len_q, seq_len_k) [attention_weight]</span></span><br><span class="line">    scaled_attention, attention_weights = scaled_dot_product_attention(</span><br><span class="line">        q, k, v, mask)</span><br><span class="line">    </span><br><span class="line">    scaled_attention = tf.transpose(scaled_attention, perm=[<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>])  <span class="comment"># (batch_size, seq_len_v, num_heads, depth)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># step 3: concat Heads</span></span><br><span class="line">    concat_attention = tf.reshape(scaled_attention, </span><br><span class="line">                                  (batch_size, <span class="number">-1</span>, self.d_model))  <span class="comment"># (batch_size, seq_len_v, d_model)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># step 4: Final FC</span></span><br><span class="line">    output = self.dense(concat_attention)  <span class="comment"># (batch_size, seq_len_v, d_model)</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> output, attention_weights</span><br></pre></td></tr></table></figure>
<p>Create a <code>MultiHeadAttention</code> layer to try out. At each location in the sequence, <code>y</code>, the <code>MultiHeadAttention</code> runs all 8 attention heads across all other locations in the sequence, returning a new vector of the same length at each location.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">temp_mha = MultiHeadAttention(d_model=<span class="number">512</span>, num_heads=<span class="number">8</span>)</span><br><span class="line">y = tf.random.uniform((<span class="number">1</span>, <span class="number">60</span>, <span class="number">512</span>))  <span class="comment"># (batch_size, encoder_sequence, d_model)</span></span><br><span class="line">out, attn = temp_mha(y, k=y, q=y, mask=<span class="keyword">None</span>)</span><br><span class="line">out.shape, attn.shape</span><br></pre></td></tr></table></figure>
<pre><code>(TensorShape([1, 60, 512]), TensorShape([1, 8, 60, 60]))
</code></pre><h2 id="Point-wise-feed-forward-network"><a href="#Point-wise-feed-forward-network" class="headerlink" title="Point wise feed forward network"></a>Point wise feed forward network</h2><p>Point wise feed forward network consists of two fully-connected layers with a ReLU activation in between.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">point_wise_feed_forward_network</span><span class="params">(d_model, dff)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> tf.keras.Sequential([</span><br><span class="line">      tf.keras.layers.Dense(dff, activation=<span class="string">'relu'</span>),  <span class="comment"># (batch_size, seq_len, dff)</span></span><br><span class="line">      tf.keras.layers.Dense(d_model)  <span class="comment"># (batch_size, seq_len, d_model)</span></span><br><span class="line">  ])</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sample_ffn = point_wise_feed_forward_network(<span class="number">512</span>, <span class="number">2048</span>)</span><br><span class="line">sample_ffn(tf.random.uniform((<span class="number">64</span>, <span class="number">50</span>, <span class="number">512</span>))).shape</span><br></pre></td></tr></table></figure>
<pre><code>TensorShape([64, 50, 512])
</code></pre><h1 id="Attention-and-Multi-Head-module-finished"><a href="#Attention-and-Multi-Head-module-finished" class="headerlink" title="Attention and Multi-Head module finished"></a>Attention and Multi-Head module finished</h1><hr>
<h2 id="Encoder-and-decoder"><a href="#Encoder-and-decoder" class="headerlink" title="Encoder and decoder"></a>Encoder and decoder</h2><p><img src="https://www.tensorflow.org/images/tutorials/transformer/transformer.png" width="600" alt="transformer"></p>
<p>The transformer model follows the same general pattern as a standard <a href="nmt_with_attention.ipynb">sequence to sequence with attention model</a>. </p>
<ul>
<li>The input sentence is passed through <code>N</code> encoder layers that generates an output for each word/token in the sequence.</li>
<li>The decoder attends on the <strong>encoderâ€™s output</strong> and its <strong>own input (self-attention)</strong> to predict the next word. </li>
</ul>
<h3 id="Encoder-layer"><a href="#Encoder-layer" class="headerlink" title="Encoder layer"></a>Encoder layer</h3><p>Each encoder layer consists of sublayers:</p>
<ol>
<li><strong>Multi-head attention (with padding mask)</strong></li>
<li><strong>Point wise feed forward networks.</strong></li>
</ol>
<p>Each of these sublayers has a <strong>residual connection</strong> around it followed by a layer normalization. Residual connections help in avoiding the vanishing gradient problem in deep networks.</p>
<p>The output of each sublayer is <code>LayerNorm(x + Sublayer(x))</code>. The normalization is done on the <code>d_model</code> (last) axis. There are N encoder layers in the transformer.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EncoderLayer</span><span class="params">(tf.keras.layers.Layer)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, d_model, num_heads, dff, rate=<span class="number">0.1</span>)</span>:</span></span><br><span class="line">    super(EncoderLayer, self).__init__()</span><br><span class="line"></span><br><span class="line">    self.mha = MultiHeadAttention(d_model, num_heads)</span><br><span class="line">    self.ffn = point_wise_feed_forward_network(d_model, dff)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># <span class="doctag">TODO:</span> åŸæ–‡ä»¶å®šä¹‰ä¸ºLayerNormalizationï¼Œæ²¡æœ‰è¿™ä¸ªAPI</span></span><br><span class="line">    self.layernorm1 = tf.keras.layers.BatchNormalization(epsilon=<span class="number">1e-6</span>)</span><br><span class="line">    self.layernorm2 = tf.keras.layers.BatchNormalization(epsilon=<span class="number">1e-6</span>)</span><br><span class="line">    </span><br><span class="line">    self.dropout1 = tf.keras.layers.Dropout(rate)</span><br><span class="line">    self.dropout2 = tf.keras.layers.Dropout(rate)</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">call</span><span class="params">(self, x, training, mask)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># step 1: Multi-head attention (encoderä¹Ÿåšäº†self-attentionï¼Œåªä¸è¿‡Q, V, K éƒ½æ˜¯ x è‡ªå·±)</span></span><br><span class="line">    attn_output, _ = self.mha(x, x, x, mask)  <span class="comment"># (batch_size, input_seq_len, d_model)</span></span><br><span class="line">    <span class="comment">## add dropout</span></span><br><span class="line">    attn_output = self.dropout1(attn_output, training=training)</span><br><span class="line">    <span class="comment">## add residual before norm</span></span><br><span class="line">    out1 = self.layernorm1(x + attn_output)  <span class="comment"># (batch_size, input_seq_len, d_model)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># step 2: Feed forward networks</span></span><br><span class="line">    ffn_output = self.ffn(out1)  <span class="comment"># (batch_size, input_seq_len, d_model)</span></span><br><span class="line">    <span class="comment">## add dropout</span></span><br><span class="line">    ffn_output = self.dropout2(ffn_output, training=training)</span><br><span class="line">    <span class="comment">## add residual before norm</span></span><br><span class="line">    out2 = self.layernorm2(out1 + ffn_output)  <span class="comment"># (batch_size, input_seq_len, d_model)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> out2</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sample_encoder_layer = EncoderLayer(<span class="number">512</span>, <span class="number">8</span>, <span class="number">2048</span>)</span><br><span class="line"></span><br><span class="line">sample_encoder_layer_output = sample_encoder_layer(</span><br><span class="line">    tf.random.uniform((<span class="number">64</span>, <span class="number">43</span>, <span class="number">512</span>)), <span class="keyword">False</span>, <span class="keyword">None</span>)</span><br><span class="line"></span><br><span class="line">sample_encoder_layer_output.shape  <span class="comment"># (batch_size, input_seq_len, d_model)</span></span><br></pre></td></tr></table></figure>
<pre><code>TensorShape([64, 43, 512])
</code></pre><h3 id="Decoder-layer"><a href="#Decoder-layer" class="headerlink" title="Decoder layer"></a>Decoder layer</h3><p>Each decoder layer consists of sublayers:</p>
<ol>
<li>Masked multi-head attention (with look ahead mask and padding mask)</li>
<li>Multi-head attention (with padding mask). V (value) and K (key) receive the <em>encoder output</em> as inputs. Q (query) receives the <em>output from the masked multi-head attention sublayer.</em></li>
<li>Point wise feed forward networks</li>
</ol>
<p>Each of these sublayers has a residual connection around it followed by a layer normalization. The output of each sublayer is <code>LayerNorm(x + Sublayer(x))</code>. The normalization is done on the <code>d_model</code> (last) axis.</p>
<p>There are N decoder layers in the transformer.</p>
<p>As Q receives the output from decoderâ€™s first attention block, and K receives the encoder output, the attention weights represent the importance given to the decoderâ€™s input based on the encoderâ€™s output. In other words, the decoder predicts the next word by looking at the encoder output and self-attending to its own output. See the demonstration above in the scaled dot product attention section.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DecoderLayer</span><span class="params">(tf.keras.layers.Layer)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, d_model, num_heads, dff, rate=<span class="number">0.1</span>)</span>:</span></span><br><span class="line">    super(DecoderLayer, self).__init__()</span><br><span class="line"></span><br><span class="line">    self.mha1 = MultiHeadAttention(d_model, num_heads)</span><br><span class="line">    self.mha2 = MultiHeadAttention(d_model, num_heads)</span><br><span class="line"></span><br><span class="line">    self.ffn = point_wise_feed_forward_network(d_model, dff)</span><br><span class="line"> </span><br><span class="line">    self.layernorm1 = tf.keras.layers.BatchNormalization(epsilon=<span class="number">1e-6</span>)</span><br><span class="line">    self.layernorm2 = tf.keras.layers.BatchNormalization(epsilon=<span class="number">1e-6</span>)</span><br><span class="line">    self.layernorm3 = tf.keras.layers.BatchNormalization(epsilon=<span class="number">1e-6</span>)</span><br><span class="line">    </span><br><span class="line">    self.dropout1 = tf.keras.layers.Dropout(rate)</span><br><span class="line">    self.dropout2 = tf.keras.layers.Dropout(rate)</span><br><span class="line">    self.dropout3 = tf.keras.layers.Dropout(rate)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">call</span><span class="params">(self, x, enc_output, training, look_ahead_mask, padding_mask)</span>:</span></span><br><span class="line">    <span class="comment"># enc_output: shape ==&gt; (batch_size, input_seq_len, d_model)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># step 1: decoder self-attention, use look-ahead-mask</span></span><br><span class="line">    attn1, attn_weights_block1 = self.mha1(x, x, x, look_ahead_mask)  <span class="comment"># (batch_size, target_seq_len, d_model)</span></span><br><span class="line">    attn1 = self.dropout1(attn1, training=training)</span><br><span class="line">    out1 = self.layernorm1(attn1 + x)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># step 2: decoder attention on encoder. V,K from encoder, Q from decoder</span></span><br><span class="line">    attn2, attn_weights_block2 = self.mha2(</span><br><span class="line">        enc_output, enc_output, out1, padding_mask)  <span class="comment"># (batch_size, target_seq_len, d_model)</span></span><br><span class="line">    attn2 = self.dropout2(attn2, training=training)</span><br><span class="line">    out2 = self.layernorm2(attn2 + out1)  <span class="comment"># (batch_size, target_seq_len, d_model)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># step 3: feed forward networks</span></span><br><span class="line">    ffn_output = self.ffn(out2)  <span class="comment"># (batch_size, target_seq_len, d_model)</span></span><br><span class="line">    ffn_output = self.dropout3(ffn_output, training=training)</span><br><span class="line">    out3 = self.layernorm3(ffn_output + out2)  <span class="comment"># (batch_size, target_seq_len, d_model)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> out3, attn_weights_block1, attn_weights_block2</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sample_decoder_layer = DecoderLayer(<span class="number">512</span>, <span class="number">8</span>, <span class="number">2048</span>)</span><br><span class="line"></span><br><span class="line">sample_decoder_layer_output, _, _ = sample_decoder_layer(</span><br><span class="line">    tf.random.uniform((<span class="number">64</span>, <span class="number">50</span>, <span class="number">512</span>)), sample_encoder_layer_output, </span><br><span class="line">    <span class="keyword">False</span>, <span class="keyword">None</span>, <span class="keyword">None</span>)</span><br><span class="line"></span><br><span class="line">sample_decoder_layer_output.shape  <span class="comment"># (batch_size, target_seq_len, d_model)</span></span><br></pre></td></tr></table></figure>
<pre><code>TensorShape([64, 50, 512])
</code></pre><h3 id="Encoder"><a href="#Encoder" class="headerlink" title="Encoder"></a>Encoder</h3><p>The <code>Encoder</code> consists of:</p>
<ol>
<li>Input Embedding</li>
<li>Positional Encoding</li>
<li>N encoder layers</li>
</ol>
<p>The input is put through an embedding which is summed with the positional encoding. The output of this summation is the input to the encoder layers. The output of the encoder is the input to the decoder.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Encoder</span><span class="params">(tf.keras.layers.Layer)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, num_layers, d_model, num_heads, dff, input_vocab_size, </span></span></span><br><span class="line"><span class="function"><span class="params">               rate=<span class="number">0.1</span>)</span>:</span></span><br><span class="line">    super(Encoder, self).__init__()</span><br><span class="line"></span><br><span class="line">    self.d_model = d_model</span><br><span class="line">    self.num_layers = num_layers</span><br><span class="line">    </span><br><span class="line">    self.embedding = tf.keras.layers.Embedding(input_vocab_size, d_model)</span><br><span class="line">    self.pos_encoding = positional_encoding(MAX_LENGTH, self.d_model)  <span class="comment"># (1, max_seq_len, embedding_dim)</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    self.enc_layers = [EncoderLayer(d_model, num_heads, dff, rate) </span><br><span class="line">                       <span class="keyword">for</span> _ <span class="keyword">in</span> range(num_layers)]</span><br><span class="line">  </span><br><span class="line">    self.dropout = tf.keras.layers.Dropout(rate)</span><br><span class="line">        </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">call</span><span class="params">(self, x, training, mask)</span>:</span></span><br><span class="line">    <span class="comment"># x: shape ==&gt; (batch, seq_len)</span></span><br><span class="line">    seq_len = tf.shape(x)[<span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># step 1: adding embedding</span></span><br><span class="line">    x = self.embedding(x)  <span class="comment"># (batch_size, input_seq_len, d_model)</span></span><br><span class="line">    <span class="comment">## æ³¨æ„è¿™é‡Œä¹˜äº†ä¸€ä¸ªscale</span></span><br><span class="line">    x *= tf.math.sqrt(tf.cast(self.d_model, tf.float32))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># step 2: adding position encoding.</span></span><br><span class="line">    x += self.pos_encoding[:, :seq_len, :]</span><br><span class="line"></span><br><span class="line">    x = self.dropout(x, training=training)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># step 3: stack encoding layers</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(self.num_layers):</span><br><span class="line">      x = self.enc_layers[i](x, training, mask)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> x  <span class="comment"># (batch_size, input_seq_len, d_model)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sample_encoder = Encoder(num_layers=<span class="number">2</span>, d_model=<span class="number">512</span>, num_heads=<span class="number">8</span>, </span><br><span class="line">                         dff=<span class="number">2048</span>, input_vocab_size=<span class="number">8500</span>)</span><br><span class="line"></span><br><span class="line">sample_encoder_output = sample_encoder(tf.random.uniform((<span class="number">64</span>, <span class="number">40</span>)), </span><br><span class="line">                                       training=<span class="keyword">False</span>, mask=<span class="keyword">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> (sample_encoder_output.shape)  <span class="comment"># (batch_size, input_seq_len, d_model)</span></span><br></pre></td></tr></table></figure>
<pre><code>(64, 40, 512)
</code></pre><h3 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h3><p> The <code>Decoder</code> consists of:</p>
<ol>
<li>Output Embedding</li>
<li>Positional Encoding</li>
<li>N decoder layers</li>
</ol>
<p>The target is put through an embedding which is summed with the positional encoding. The output of this summation is the input to the decoder layers. The output of the decoder is the input to the final linear layer.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Decoder</span><span class="params">(tf.keras.layers.Layer)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, num_layers, d_model, num_heads, dff, target_vocab_size, </span></span></span><br><span class="line"><span class="function"><span class="params">               rate=<span class="number">0.1</span>)</span>:</span></span><br><span class="line">    super(Decoder, self).__init__()</span><br><span class="line"></span><br><span class="line">    self.d_model = d_model</span><br><span class="line">    self.num_layers = num_layers</span><br><span class="line">    </span><br><span class="line">    self.embedding = tf.keras.layers.Embedding(target_vocab_size, d_model)</span><br><span class="line">    self.pos_encoding = positional_encoding(MAX_LENGTH, self.d_model)</span><br><span class="line">    </span><br><span class="line">    self.dec_layers = [DecoderLayer(d_model, num_heads, dff, rate) </span><br><span class="line">                       <span class="keyword">for</span> _ <span class="keyword">in</span> range(num_layers)]</span><br><span class="line">    self.dropout = tf.keras.layers.Dropout(rate)</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">call</span><span class="params">(self, x, enc_output, training, look_ahead_mask, padding_mask)</span>:</span></span><br><span class="line">    <span class="comment"># x: shape ==&gt; (batch, seq_len)</span></span><br><span class="line">    seq_len = tf.shape(x)[<span class="number">1</span>]</span><br><span class="line">    attention_weights = &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># step 1: adding embedding</span></span><br><span class="line">    x = self.embedding(x)  <span class="comment"># (batch_size, target_seq_len, d_model)</span></span><br><span class="line">    <span class="comment">## æ³¨æ„è¿™é‡Œä¹˜äº†ä¸€ä¸ªscale</span></span><br><span class="line">    x *= tf.math.sqrt(tf.cast(self.d_model, tf.float32))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># step 2: adding position encoding.</span></span><br><span class="line">    x += self.pos_encoding[:, :seq_len, :]</span><br><span class="line">    </span><br><span class="line">    x = self.dropout(x, training=training)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(self.num_layers):</span><br><span class="line">      <span class="comment"># æ³¨æ„ï¼šè¿™é‡Œdecoderæ¯ä¸€å±‚ç”¨çš„encoder outputæ˜¯ä¸€æ ·çš„</span></span><br><span class="line">      x, block1, block2 = self.dec_layers[i](x, enc_output, training,</span><br><span class="line">                                             look_ahead_mask, padding_mask)</span><br><span class="line">      </span><br><span class="line">      attention_weights[<span class="string">'decoder_layer&#123;&#125;_block1'</span>.format(i+<span class="number">1</span>)] = block1</span><br><span class="line">      attention_weights[<span class="string">'decoder_layer&#123;&#125;_block2'</span>.format(i+<span class="number">1</span>)] = block2</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># x.shape == (batch_size, target_seq_len, d_model)</span></span><br><span class="line">    <span class="keyword">return</span> x, attention_weights</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sample_decoder = Decoder(num_layers=<span class="number">2</span>, d_model=<span class="number">512</span>, num_heads=<span class="number">8</span>, </span><br><span class="line">                         dff=<span class="number">2048</span>, target_vocab_size=<span class="number">8000</span>)</span><br><span class="line"></span><br><span class="line">output, attn = sample_decoder(tf.random.uniform((<span class="number">64</span>, <span class="number">26</span>)), </span><br><span class="line">                              enc_output=sample_encoder_output, </span><br><span class="line">                              training=<span class="keyword">False</span>, look_ahead_mask=<span class="keyword">None</span>, </span><br><span class="line">                              padding_mask=<span class="keyword">None</span>)</span><br><span class="line"></span><br><span class="line">output.shape, attn[<span class="string">'decoder_layer2_block2'</span>].shape</span><br></pre></td></tr></table></figure>
<pre><code>(TensorShape([64, 26, 512]), TensorShape([64, 8, 26, 40]))
</code></pre><h1 id="Each-module-built-finished"><a href="#Each-module-built-finished" class="headerlink" title="Each module built finished!"></a>Each module built finished!</h1><hr>
<h2 id="Create-the-Transformer"><a href="#Create-the-Transformer" class="headerlink" title="Create the Transformer"></a>Create the Transformer</h2><p>Transformer consists of the encoder, decoder and a final linear layer. The output of the decoder is the input to the linear layer and its output is returned.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transformer</span><span class="params">(tf.keras.Model)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, num_layers, d_model, num_heads, dff, input_vocab_size, </span></span></span><br><span class="line"><span class="function"><span class="params">               target_vocab_size, rate=<span class="number">0.1</span>)</span>:</span></span><br><span class="line">    super(Transformer, self).__init__()</span><br><span class="line"></span><br><span class="line">    self.encoder = Encoder(num_layers, d_model, num_heads, dff, </span><br><span class="line">                           input_vocab_size, rate)</span><br><span class="line"></span><br><span class="line">    self.decoder = Decoder(num_layers, d_model, num_heads, dff, </span><br><span class="line">                           target_vocab_size, rate)</span><br><span class="line"></span><br><span class="line">    self.final_layer = tf.keras.layers.Dense(target_vocab_size)</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">call</span><span class="params">(self, inp, tar, training, enc_padding_mask, </span></span></span><br><span class="line"><span class="function"><span class="params">           look_ahead_mask, dec_padding_mask)</span>:</span></span><br><span class="line"></span><br><span class="line">    enc_output = self.encoder(inp, training, enc_padding_mask)  <span class="comment"># (batch_size, inp_seq_len, d_model)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># dec_output.shape == (batch_size, tar_seq_len, d_model)</span></span><br><span class="line">    dec_output, attention_weights = self.decoder(</span><br><span class="line">        tar, enc_output, training, look_ahead_mask, dec_padding_mask)</span><br><span class="line">    </span><br><span class="line">    final_output = self.final_layer(dec_output)  <span class="comment"># (batch_size, tar_seq_len, target_vocab_size)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> final_output, attention_weights</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sample_transformer = Transformer(</span><br><span class="line">    num_layers=<span class="number">2</span>, d_model=<span class="number">512</span>, num_heads=<span class="number">8</span>, dff=<span class="number">2048</span>, </span><br><span class="line">    input_vocab_size=<span class="number">8500</span>, target_vocab_size=<span class="number">8000</span>)</span><br><span class="line"></span><br><span class="line">temp_input = tf.random.uniform((<span class="number">64</span>, <span class="number">40</span>))</span><br><span class="line">temp_target = tf.random.uniform((<span class="number">64</span>, <span class="number">26</span>))</span><br><span class="line"></span><br><span class="line">fn_out, _ = sample_transformer(temp_input, temp_target, training=<span class="keyword">False</span>, </span><br><span class="line">                               enc_padding_mask=<span class="keyword">None</span>, </span><br><span class="line">                               look_ahead_mask=<span class="keyword">None</span>,</span><br><span class="line">                               dec_padding_mask=<span class="keyword">None</span>)</span><br><span class="line"></span><br><span class="line">fn_out.shape  <span class="comment"># (batch_size, tar_seq_len, target_vocab_size)</span></span><br></pre></td></tr></table></figure>
<pre><code>TensorShape([64, 26, 8000])
</code></pre><h2 id="Set-hyperparameters"><a href="#Set-hyperparameters" class="headerlink" title="Set hyperparameters"></a>Set hyperparameters</h2><p>To keep this example small and relatively fast, the values for <em>num_layers, d_model, and dff</em> have been reduced. </p>
<p>The values used in the base model of transformer were; <em>num_layers=6</em>, <em>d_model = 512</em>, <em>dff = 2048</em>. See the <a href="https://arxiv.org/abs/1706.03762" target="_blank" rel="noopener">paper</a> for all the other versions of the transformer.</p>
<p>Note: By changing the values below, you can get the model that achieved state of the art on many tasks.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">num_layers = <span class="number">4</span></span><br><span class="line">d_model = <span class="number">128</span></span><br><span class="line">dff = <span class="number">512</span></span><br><span class="line">num_heads = <span class="number">8</span></span><br><span class="line"></span><br><span class="line">input_vocab_size = tokenizer_pt.vocab_size + <span class="number">2</span></span><br><span class="line">target_vocab_size = tokenizer_en.vocab_size + <span class="number">2</span></span><br><span class="line">dropout_rate = <span class="number">0.1</span></span><br></pre></td></tr></table></figure>
<h2 id="Optimizer"><a href="#Optimizer" class="headerlink" title="Optimizer"></a>Optimizer</h2><p>Use the Adam optimizer with a <strong>custom learning rate scheduler</strong> according to the formula in the <a href="https://arxiv.org/abs/1706.03762" target="_blank" rel="noopener">paper</a>.</p>
<p>$$\Large{lrate = d_{model}^{-0.5} <em> min(step{_}num^{-0.5}, step{_}num </em> warmup{_}steps^{-1.5})}$$</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomSchedule</span><span class="params">(tf.keras.optimizers.schedules.LearningRateSchedule)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, d_model, warmup_steps=<span class="number">4000</span>)</span>:</span></span><br><span class="line">    super(CustomSchedule, self).__init__()</span><br><span class="line">    </span><br><span class="line">    self.d_model = d_model</span><br><span class="line">    self.d_model = tf.cast(self.d_model, tf.float32)</span><br><span class="line"></span><br><span class="line">    self.warmup_steps = warmup_steps</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, step)</span>:</span></span><br><span class="line">    arg1 = tf.math.rsqrt(step)</span><br><span class="line">    arg2 = step * (self.warmup_steps ** <span class="number">-1.5</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> tf.math.rsqrt(self.d_model) * tf.math.minimum(arg1, arg2)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">learning_rate = CustomSchedule(d_model)</span><br><span class="line"></span><br><span class="line">optimizer = tf.keras.optimizers.Adam(learning_rate, beta_1=<span class="number">0.9</span>, beta_2=<span class="number">0.98</span>, </span><br><span class="line">                                     epsilon=<span class="number">1e-9</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">temp_learning_rate_schedule = CustomSchedule(d_model)</span><br><span class="line"></span><br><span class="line">plt.plot(temp_learning_rate_schedule(tf.range(<span class="number">40000</span>, dtype=tf.float32)))</span><br><span class="line">plt.ylabel(<span class="string">"Learning Rate"</span>)</span><br><span class="line">plt.xlabel(<span class="string">"Train Step"</span>)</span><br></pre></td></tr></table></figure>
<pre><code>Text(0.5,0,&apos;Train Step&apos;)
</code></pre><p><img src="/images/transformer/output_82_1.png" alt="png"></p>
<h2 id="Loss-and-metrics"><a href="#Loss-and-metrics" class="headerlink" title="Loss and metrics"></a>Loss and metrics</h2><p>Since the target sequences are padded, it is important to apply a padding mask when calculating the loss.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">loss_object = tf.keras.losses.SparseCategoricalCrossentropy(</span><br><span class="line">    from_logits=<span class="keyword">True</span>, reduction=<span class="string">'none'</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loss_function</span><span class="params">(real, pred)</span>:</span></span><br><span class="line">  mask = tf.math.logical_not(tf.math.equal(real, <span class="number">0</span>))</span><br><span class="line">  loss_ = loss_object(real, pred)</span><br><span class="line"></span><br><span class="line">  mask = tf.cast(mask, dtype=loss_.dtype)</span><br><span class="line">  loss_ *= mask</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> tf.reduce_mean(loss_)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">train_loss = tf.keras.metrics.Mean(name=<span class="string">'train_loss'</span>)</span><br><span class="line">train_accuracy = tf.keras.metrics.SparseCategoricalAccuracy(</span><br><span class="line">    name=<span class="string">'train_accuracy'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="Training-and-checkpointing"><a href="#Training-and-checkpointing" class="headerlink" title="Training and checkpointing"></a>Training and checkpointing</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">transformer = Transformer(num_layers, d_model, num_heads, dff,</span><br><span class="line">                          input_vocab_size, target_vocab_size, dropout_rate)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_masks</span><span class="params">(inp, tar)</span>:</span></span><br><span class="line">  <span class="comment"># Encoder padding mask</span></span><br><span class="line">  enc_padding_mask = create_padding_mask(inp)</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># Used in the 2nd attention block in the decoder.</span></span><br><span class="line">  <span class="comment"># This padding mask is used to mask the encoder outputs.</span></span><br><span class="line">  dec_padding_mask = create_padding_mask(inp)</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># Used in the 1st attention block in the decoder.</span></span><br><span class="line">  <span class="comment"># It is used to pad and mask future tokens in the input received by </span></span><br><span class="line">  <span class="comment"># the decoder.</span></span><br><span class="line">  look_ahead_mask = create_look_ahead_mask(tf.shape(tar)[<span class="number">1</span>])</span><br><span class="line">  dec_target_padding_mask = create_padding_mask(tar)</span><br><span class="line">  combined_mask = tf.maximum(dec_target_padding_mask, look_ahead_mask)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> enc_padding_mask, combined_mask, dec_padding_mask</span><br></pre></td></tr></table></figure>
<p>Create the checkpoint path and the checkpoint manager. This will be used to save checkpoints every <code>n</code> epochs.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">checkpoint_path = <span class="string">"./model/transformer/checkpoints/train"</span></span><br><span class="line"></span><br><span class="line">ckpt = tf.train.Checkpoint(transformer=transformer,</span><br><span class="line">                           optimizer=optimizer)</span><br><span class="line"></span><br><span class="line">ckpt_manager = tf.train.CheckpointManager(ckpt, checkpoint_path, max_to_keep=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># if a checkpoint exists, restore the latest checkpoint.</span></span><br><span class="line"><span class="keyword">if</span> ckpt_manager.latest_checkpoint:</span><br><span class="line">  ckpt.restore(ckpt_manager.latest_checkpoint)</span><br><span class="line">  <span class="keyword">print</span> (<span class="string">'Latest checkpoint restored!!'</span>)</span><br></pre></td></tr></table></figure>
<p>The target is divided into tar_inp and tar_real. tar_inp is passed as an input to the decoder. <code>tar_real</code> is that same input shifted by 1: At each location in <code>tar_input</code>, <code>tar_real</code> contains the <strong>next token that should be predicted</strong>.</p>
<p><strong>SOS=start of sentence, EOS=end of sentence</strong></p>
<p>For example, <code>sentence</code> = â€œSOS A lion in the jungle is sleeping EOSâ€</p>
<p><code>tar_inp</code> =  â€œSOS A lion in the jungle is sleepingâ€</p>
<p><code>tar_real</code> = â€œA lion in the jungle is sleeping EOSâ€</p>
<p>The transformer is an <strong>auto-regressive model</strong>: it makes predictions one part at a time, and uses its output so far to decide what to do next. </p>
<p>æ³¨æ„<strong>teacher-forcing</strong>çš„æ¦‚å¿µï¼Œåœ¨trainçš„æ—¶å€™ç”¨real labelä¼ ç»™ä¸‹ä¸€ä¸ªstepã€‚</p>
<p>During training this example uses <strong>teacher-forcing</strong> (like in the <a href="./text_generation.ipynb">text generation tutorial</a>). Teacher forcing is passing the true output to the next time step regardless of what the model predicts at the current time step.</p>
<p>As the transformer predicts each word, <em>self-attention</em> allows it to look at the previous words in the input sequence to better predict the next word.</p>
<p>To prevent the model from peaking at the expected output the model uses a look-ahead mask.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EPOCHS = <span class="number">20</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@tf.function</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_step</span><span class="params">(inp, tar)</span>:</span></span><br><span class="line">  tar_inp = tar[:, :<span class="number">-1</span>]</span><br><span class="line">  tar_real = tar[:, <span class="number">1</span>:]</span><br><span class="line">  </span><br><span class="line">  enc_padding_mask, combined_mask, dec_padding_mask = create_masks(inp, tar_inp)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">with</span> tf.GradientTape() <span class="keyword">as</span> tape:</span><br><span class="line">    predictions, _ = transformer(inp, tar_inp, </span><br><span class="line">                                 <span class="keyword">True</span>, </span><br><span class="line">                                 enc_padding_mask, </span><br><span class="line">                                 combined_mask, </span><br><span class="line">                                 dec_padding_mask)</span><br><span class="line">    loss = loss_function(tar_real, predictions)</span><br><span class="line"></span><br><span class="line">  gradients = tape.gradient(loss, transformer.trainable_variables)    </span><br><span class="line">  optimizer.apply_gradients(zip(gradients, transformer.trainable_variables))</span><br><span class="line">  </span><br><span class="line">  train_loss(loss)</span><br><span class="line">  train_accuracy(tar_real, predictions)</span><br></pre></td></tr></table></figure>
<p>Portuguese is used as the input language and English is the target language.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(EPOCHS):</span><br><span class="line">  start = time.time()</span><br><span class="line">  </span><br><span class="line">  train_loss.reset_states()</span><br><span class="line">  train_accuracy.reset_states()</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># inp -&gt; portuguese, tar -&gt; english</span></span><br><span class="line">  <span class="comment"># æ³¨æ„ï¼šdatasetæ˜¯é€šè¿‡è‡ªå®šä¹‰encode()å’Œfilter() functionåç”Ÿæˆçš„</span></span><br><span class="line">  <span class="keyword">for</span> (batch, (inp, tar)) <span class="keyword">in</span> enumerate(train_dataset):</span><br><span class="line">    train_step(inp, tar)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> batch % <span class="number">500</span> == <span class="number">0</span>:</span><br><span class="line">      <span class="keyword">print</span> (<span class="string">'Epoch &#123;&#125; Batch &#123;&#125; Loss &#123;:.4f&#125; Accuracy &#123;:.4f&#125;'</span>.format(</span><br><span class="line">          epoch + <span class="number">1</span>, batch, train_loss.result(), train_accuracy.result()))</span><br><span class="line">      </span><br><span class="line">  <span class="keyword">if</span> (epoch + <span class="number">1</span>) % <span class="number">5</span> == <span class="number">0</span>:</span><br><span class="line">    ckpt_save_path = ckpt_manager.save()</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'Saving checkpoint for epoch &#123;&#125; at &#123;&#125;'</span>.format(epoch+<span class="number">1</span>,</span><br><span class="line">                                                         ckpt_save_path))</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">print</span> (<span class="string">'Epoch &#123;&#125; Loss &#123;:.4f&#125; Accuracy &#123;:.4f&#125;'</span>.format(epoch + <span class="number">1</span>, </span><br><span class="line">                                                train_loss.result(), </span><br><span class="line">                                                train_accuracy.result()))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">print</span> (<span class="string">'Time taken for 1 epoch: &#123;&#125; secs\n'</span>.format(time.time() - start))</span><br></pre></td></tr></table></figure>
<pre><code>Epoch 1 Batch 0 Loss 10.9017 Accuracy 0.0000
Epoch 1 Batch 500 Loss 4.0922 Accuracy 0.0294
Epoch 1 Loss 3.7079 Accuracy 0.0443
Time taken for 1 epoch: 110.26966953277588 secs

Epoch 2 Batch 0 Loss 2.5675 Accuracy 0.0855
Epoch 2 Batch 500 Loss 2.3795 Accuracy 0.1250
Epoch 2 Loss 2.3093 Accuracy 0.1324
Time taken for 1 epoch: 82.4690248966217 secs

Epoch 3 Batch 0 Loss 2.0194 Accuracy 0.1517
Epoch 3 Batch 500 Loss 1.9885 Accuracy 0.1704
Epoch 3 Loss 1.9433 Accuracy 0.1747
Time taken for 1 epoch: 84.78626227378845 secs

Epoch 4 Batch 0 Loss 1.7177 Accuracy 0.1863
Epoch 4 Batch 500 Loss 1.7245 Accuracy 0.1992
Epoch 4 Loss 1.6884 Accuracy 0.2023
Time taken for 1 epoch: 83.60331654548645 secs

Epoch 5 Batch 0 Loss 1.5059 Accuracy 0.2113
Epoch 5 Batch 500 Loss 1.5126 Accuracy 0.2209
Saving checkpoint for epoch 5 at ./model/transformer/checkpoints/train/ckpt-1
Epoch 5 Loss 1.4843 Accuracy 0.2230
Time taken for 1 epoch: 83.2209415435791 secs

Epoch 6 Batch 0 Loss 1.3257 Accuracy 0.2278
Epoch 6 Batch 500 Loss 1.3507 Accuracy 0.2370
Epoch 6 Loss 1.3275 Accuracy 0.2390
Time taken for 1 epoch: 79.70339369773865 secs

Epoch 7 Batch 0 Loss 1.2014 Accuracy 0.2451
Epoch 7 Batch 500 Loss 1.1911 Accuracy 0.2556
Epoch 7 Loss 1.1679 Accuracy 0.2577
Time taken for 1 epoch: 80.37797617912292 secs

Epoch 8 Batch 0 Loss 1.0367 Accuracy 0.2751
Epoch 8 Batch 500 Loss 1.0560 Accuracy 0.2726
Epoch 8 Loss 1.0396 Accuracy 0.2739
Time taken for 1 epoch: 84.6077356338501 secs

Epoch 9 Batch 0 Loss 0.9316 Accuracy 0.2829
Epoch 9 Batch 500 Loss 0.9606 Accuracy 0.2844
Epoch 9 Loss 0.9490 Accuracy 0.2852
Time taken for 1 epoch: 84.28984260559082 secs

Epoch 10 Batch 0 Loss 0.8716 Accuracy 0.2862
Epoch 10 Batch 500 Loss 0.8863 Accuracy 0.2937
Saving checkpoint for epoch 10 at ./model/transformer/checkpoints/train/ckpt-2
Epoch 10 Loss 0.8778 Accuracy 0.2942
Time taken for 1 epoch: 85.24914264678955 secs

Epoch 11 Batch 0 Loss 0.8273 Accuracy 0.2915
Epoch 11 Batch 500 Loss 0.8279 Accuracy 0.3018
Epoch 11 Loss 0.8208 Accuracy 0.3021
Time taken for 1 epoch: 84.971688747406 secs

Epoch 12 Batch 0 Loss 0.7629 Accuracy 0.3059
Epoch 12 Batch 500 Loss 0.7773 Accuracy 0.3086
Epoch 12 Loss 0.7714 Accuracy 0.3089
Time taken for 1 epoch: 84.43891286849976 secs

Epoch 13 Batch 0 Loss 0.7163 Accuracy 0.3063
Epoch 13 Batch 500 Loss 0.7394 Accuracy 0.3136
Epoch 13 Loss 0.7331 Accuracy 0.3139
Time taken for 1 epoch: 84.75990414619446 secs

Epoch 14 Batch 0 Loss 0.6871 Accuracy 0.3133
Epoch 14 Batch 500 Loss 0.7013 Accuracy 0.3190
Epoch 14 Loss 0.6963 Accuracy 0.3191
Time taken for 1 epoch: 85.32253313064575 secs

Epoch 15 Batch 0 Loss 0.6414 Accuracy 0.3162
Epoch 15 Batch 500 Loss 0.6717 Accuracy 0.3235
Saving checkpoint for epoch 15 at ./model/transformer/checkpoints/train/ckpt-3
Epoch 15 Loss 0.6675 Accuracy 0.3235
Time taken for 1 epoch: 84.33578681945801 secs

Epoch 16 Batch 0 Loss 0.6201 Accuracy 0.3232
Epoch 16 Batch 500 Loss 0.6434 Accuracy 0.3278
Epoch 16 Loss 0.6397 Accuracy 0.3277
Time taken for 1 epoch: 82.0535318851471 secs

Epoch 17 Batch 0 Loss 0.5928 Accuracy 0.3298
Epoch 17 Batch 500 Loss 0.6186 Accuracy 0.3315
Epoch 17 Loss 0.6156 Accuracy 0.3312
Time taken for 1 epoch: 86.0015115737915 secs

Epoch 18 Batch 0 Loss 0.5472 Accuracy 0.3343
Epoch 18 Batch 500 Loss 0.5961 Accuracy 0.3348
Epoch 18 Loss 0.5929 Accuracy 0.3346
Time taken for 1 epoch: 85.77375030517578 secs

Epoch 19 Batch 0 Loss 0.5477 Accuracy 0.3343
Epoch 19 Batch 500 Loss 0.5746 Accuracy 0.3385
Epoch 19 Loss 0.5726 Accuracy 0.3379
Time taken for 1 epoch: 86.64751982688904 secs

Epoch 20 Batch 0 Loss 0.5593 Accuracy 0.3331
Epoch 20 Batch 500 Loss 0.5569 Accuracy 0.3414
Saving checkpoint for epoch 20 at ./model/transformer/checkpoints/train/ckpt-4
Epoch 20 Loss 0.5543 Accuracy 0.3410
Time taken for 1 epoch: 82.36839008331299 secs
</code></pre><h1 id="Training-finished"><a href="#Training-finished" class="headerlink" title="Training finished"></a>Training finished</h1><hr>
<h2 id="Evaluate"><a href="#Evaluate" class="headerlink" title="Evaluate"></a>Evaluate</h2><p>The following steps are used for evaluation:</p>
<ul>
<li>Encode the input sentence using the Portuguese tokenizer (<code>tokenizer_pt</code>). Moreover, add the start and end token so the input is equivalent to what the model is trained with. This is the encoder input.</li>
<li>The decoder input is the <code>start token == tokenizer_en.vocab_size</code>.</li>
<li>Calculate the padding masks and the look ahead masks.</li>
<li>The <code>decoder</code> then outputs the predictions by looking at the <code>encoder output</code> and its own output (self-attention).</li>
<li>Select the last word and calculate the argmax of that.</li>
<li>Concatentate the predicted word to the decoder input as pass it to the decoder.</li>
<li>In this approach, the decoder predicts the next word based on the previous words it predicted.</li>
</ul>
<p>Note: The model used here has less capacity to keep the example relatively faster so the predictions maybe less right. To reproduce the results in the paper, use the entire dataset and base transformer model or transformer XL, by changing the hyperparameters above.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evaluate</span><span class="params">(inp_sentence)</span>:</span></span><br><span class="line">  start_token = [tokenizer_pt.vocab_size]</span><br><span class="line">  end_token = [tokenizer_pt.vocab_size + <span class="number">1</span>]</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># step 1: inp sentence is portuguese, hence adding the start and end token</span></span><br><span class="line">  inp_sentence = start_token + tokenizer_pt.encode(inp_sentence) + end_token</span><br><span class="line">  encoder_input = tf.expand_dims(inp_sentence, <span class="number">0</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># step 2: decoder</span></span><br><span class="line">  <span class="comment"># as the target is english, the first word to the transformer should be the english start token.</span></span><br><span class="line">  <span class="comment"># æ³¨æ„ï¼šdecoderè¿™é‡Œåªappendäº†â€œStart of sentenceâ€</span></span><br><span class="line">  decoder_input = [tokenizer_en.vocab_size]</span><br><span class="line">  output = tf.expand_dims(decoder_input, <span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(MAX_LENGTH):</span><br><span class="line">    <span class="comment"># step 3: create mask</span></span><br><span class="line">    enc_padding_mask, combined_mask, dec_padding_mask = create_masks(</span><br><span class="line">        encoder_input, output)</span><br><span class="line">  </span><br><span class="line">    <span class="comment"># step 4: make predicitons</span></span><br><span class="line">    <span class="comment"># predictions.shape == (batch_size, seq_len, vocab_size)</span></span><br><span class="line">    predictions, attention_weights = transformer(encoder_input, </span><br><span class="line">                                                 output,</span><br><span class="line">                                                 <span class="keyword">False</span>,</span><br><span class="line">                                                 enc_padding_mask,</span><br><span class="line">                                                 combined_mask,</span><br><span class="line">                                                 dec_padding_mask)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># step 5: select the last word from the seq_len dimension</span></span><br><span class="line">    predictions = predictions[: ,<span class="number">-1</span>:, :]  <span class="comment"># (batch_size, 1, vocab_size)</span></span><br><span class="line"></span><br><span class="line">    predicted_id = tf.cast(tf.argmax(predictions, axis=<span class="number">-1</span>), tf.int32)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># step 6: å¦‚æœä¸æ˜¯EOSï¼Œç»“æœappendåˆ°outputé‡Œä¾›ä¸‹ä¸€æ¬¡é¢„æµ‹</span></span><br><span class="line">    <span class="comment"># return the result if the predicted_id is equal to the end token</span></span><br><span class="line">    <span class="keyword">if</span> tf.equal(predicted_id, tokenizer_en.vocab_size+<span class="number">1</span>):</span><br><span class="line">      <span class="keyword">return</span> tf.squeeze(output, axis=<span class="number">0</span>), attention_weights</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># concatentate the predicted_id to the output which is given to the decoder</span></span><br><span class="line">    <span class="comment"># as its input.</span></span><br><span class="line">    output = tf.concat([output, predicted_id], axis=<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> tf.squeeze(output, axis=<span class="number">0</span>), attention_weights</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_attention_weights</span><span class="params">(attention, sentence, result, layer)</span>:</span></span><br><span class="line">  fig = plt.figure(figsize=(<span class="number">16</span>, <span class="number">8</span>))</span><br><span class="line">  </span><br><span class="line">  sentence = tokenizer_pt.encode(sentence)</span><br><span class="line">  </span><br><span class="line">  attention = tf.squeeze(attention[layer], axis=<span class="number">0</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> head <span class="keyword">in</span> range(attention.shape[<span class="number">0</span>]):</span><br><span class="line">    ax = fig.add_subplot(<span class="number">2</span>, <span class="number">4</span>, head+<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># plot the attention weights</span></span><br><span class="line">    ax.matshow(attention[head][:<span class="number">-1</span>, :], cmap=<span class="string">'viridis'</span>)</span><br><span class="line"></span><br><span class="line">    fontdict = &#123;<span class="string">'fontsize'</span>: <span class="number">10</span>&#125;</span><br><span class="line">    </span><br><span class="line">    ax.set_xticks(range(len(sentence)+<span class="number">2</span>))</span><br><span class="line">    ax.set_yticks(range(len(result)))</span><br><span class="line">    </span><br><span class="line">    ax.set_ylim(len(result)<span class="number">-1.5</span>, <span class="number">-0.5</span>)</span><br><span class="line">        </span><br><span class="line">    ax.set_xticklabels(</span><br><span class="line">        [<span class="string">'&lt;start&gt;'</span>]+[tokenizer_pt.decode([i]) <span class="keyword">for</span> i <span class="keyword">in</span> sentence]+[<span class="string">'&lt;end&gt;'</span>], </span><br><span class="line">        fontdict=fontdict, rotation=<span class="number">90</span>)</span><br><span class="line">    </span><br><span class="line">    ax.set_yticklabels([tokenizer_en.decode([i]) <span class="keyword">for</span> i <span class="keyword">in</span> result </span><br><span class="line">                        <span class="keyword">if</span> i &lt; tokenizer_en.vocab_size], </span><br><span class="line">                       fontdict=fontdict)</span><br><span class="line">    </span><br><span class="line">    ax.set_xlabel(<span class="string">'Head &#123;&#125;'</span>.format(head+<span class="number">1</span>))</span><br><span class="line">  </span><br><span class="line">  plt.tight_layout()</span><br><span class="line">  plt.show()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">translate</span><span class="params">(sentence, plot=<span class="string">''</span>)</span>:</span></span><br><span class="line">  result, attention_weights = evaluate(sentence)</span><br><span class="line">  </span><br><span class="line">  predicted_sentence = tokenizer_en.decode([i <span class="keyword">for</span> i <span class="keyword">in</span> result </span><br><span class="line">                                            <span class="keyword">if</span> i &lt; tokenizer_en.vocab_size])  </span><br><span class="line"></span><br><span class="line">  print(<span class="string">'Input: &#123;&#125;'</span>.format(sentence))</span><br><span class="line">  print(<span class="string">'Predicted translation: &#123;&#125;'</span>.format(predicted_sentence))</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> plot:</span><br><span class="line">    plot_attention_weights(attention_weights, sentence, result, plot)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">translate(<span class="string">"este Ã© um problema que temos que resolver."</span>)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"Real translation: this is a problem we have to solve ."</span>)</span><br></pre></td></tr></table></figure>
<pre><code>Input: este Ã© um problema que temos que resolver.
Predicted translation: this is a problem that we have to solve for.com .
Real translation: this is a problem we have to solve .
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">translate(<span class="string">"os meus vizinhos ouviram sobre esta ideia."</span>)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"Real translation: and my neighboring homes heard about this idea ."</span>)</span><br></pre></td></tr></table></figure>
<pre><code>Input: os meus vizinhos ouviram sobre esta ideia.
Predicted translation: my neighbors heard about this idea .
Real translation: and my neighboring homes heard about this idea .
</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">translate(<span class="string">"vou entÃ£o muito rapidamente partilhar convosco algumas histÃ³rias de algumas coisas mÃ¡gicas que aconteceram."</span>)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"Real translation: so i 'll just share with you some stories very quickly of some magical things that have happened ."</span>)</span><br></pre></td></tr></table></figure>
<pre><code>Input: vou entÃ£o muito rapidamente partilhar convosco algumas histÃ³rias de algumas coisas mÃ¡gicas que aconteceram.
Predicted translation: so i &apos;m going to share a lot of little bit with you a few things that happened .
Real translation: so i &apos;ll just share with you some stories very quickly of some magical things that have happened .
</code></pre><p>You can pass different layers and attention blocks of the decoder to the <code>plot</code> parameter.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">translate(<span class="string">"este Ã© o primeiro livro que eu fiz."</span>, plot=<span class="string">'decoder_layer4_block2'</span>)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"Real translation: this is the first book i've ever done."</span>)</span><br></pre></td></tr></table></figure>
<pre><code>Input: este Ã© o primeiro livro que eu fiz.
Predicted translation: this is the first book i made .
</code></pre><p><img src="/images/transformer/output_107_1.png" alt="png"></p>
<pre><code>Real translation: this is the first book i&apos;ve ever done.
</code></pre><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>In this tutorial, you learned about positional encoding, multi-head attention, the importance of masking and how to create a transformer.</p>
<p>Try using a different dataset to train the transformer. You can also create the base transformer or transformer XL by changing the hyperparameters above. You can also use the layers defined here to create <a href="https://arxiv.org/abs/1810.04805" target="_blank" rel="noopener">BERT</a> and train state of the art models. Futhermore, you can implement beam search to get better predictions.</p>
</section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#Transformer">
    <span class="tag-code">Transformer</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2019/01/06/dcgan/">
        <span class="nav-arrow">â† </span>
        
          dcgan
        
      </a>
    
    
  </div>

    <!-- NAV END -->
    
      <!-- Gitment START -->
      <div id="comments"></div>
      <!-- Gitment END -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#Copyright-2019-The-TensorFlow-Authors"><span class="toc-nav-text">Copyright 2019 The TensorFlow Authors.</span></a></li></ol><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#Transformer-model-for-language-understanding"><span class="toc-nav-text">Transformer model for language understanding</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Setup-input-pipeline"><span class="toc-nav-text">Setup input pipeline</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Positional-encoding"><span class="toc-nav-text">Positional encoding</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Masking"><span class="toc-nav-text">Masking</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#Preprocessing-finished"><span class="toc-nav-text">Preprocessing finished</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Scaled-dot-product-attention"><span class="toc-nav-text">Scaled dot product attention</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Multi-head-attention"><span class="toc-nav-text">Multi-head attention</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Point-wise-feed-forward-network"><span class="toc-nav-text">Point wise feed forward network</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#Attention-and-Multi-Head-module-finished"><span class="toc-nav-text">Attention and Multi-Head module finished</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Encoder-and-decoder"><span class="toc-nav-text">Encoder and decoder</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Encoder-layer"><span class="toc-nav-text">Encoder layer</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Decoder-layer"><span class="toc-nav-text">Decoder layer</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Encoder"><span class="toc-nav-text">Encoder</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Decoder"><span class="toc-nav-text">Decoder</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#Each-module-built-finished"><span class="toc-nav-text">Each module built finished!</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Create-the-Transformer"><span class="toc-nav-text">Create the Transformer</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Set-hyperparameters"><span class="toc-nav-text">Set hyperparameters</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Optimizer"><span class="toc-nav-text">Optimizer</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Loss-and-metrics"><span class="toc-nav-text">Loss and metrics</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Training-and-checkpointing"><span class="toc-nav-text">Training and checkpointing</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#Training-finished"><span class="toc-nav-text">Training finished</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Evaluate"><span class="toc-nav-text">Evaluate</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#Summary"><span class="toc-nav-text">Summary</span></a>
    
  </li></ol></li></div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'http://yoursite.com/2019/05/26/transformer/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

     // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', 'http://file.muyutech.com/error-img.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== 'http://file.muyutech.com/error-img.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()
        
        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })

    // qrcode
    var qr = new QRious({
      element: document.getElementById('share-qrcode'),
      value: document.location.href
    });

    // gitment
    var gitmentConfig = "dongnanzhy";
    if (gitmentConfig !== 'undefined') {
      var gitment = new Gitment({
        id: "transformer",
        owner: "dongnanzhy",
        repo: "dongnanzhy.github.io",
        oauth: {
          client_id: "6e8efba4b92de298d180",
          client_secret: "ef25328fb6ac8348ad6921d892776be451db3639"
        },
        theme: {
          render(state, instance) {
            const container = document.createElement('div')
            container.lang = "en-US"
            container.className = 'gitment-container gitment-root-container'
            container.appendChild(instance.renderHeader(state, instance))
            container.appendChild(instance.renderEditor(state, instance))
            container.appendChild(instance.renderComments(state, instance))
            container.appendChild(instance.renderFooter(state, instance))
            return container;
          }
        }
      })
      gitment.render(document.getElementById('comments'))
    }
  })();
</script>

<script>
  var disqus_shortname = '';
  
  var disqus_url = 'http://yoursite.com/2019/05/26/transformer/';
  
  (function(){
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//go.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>

    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2019 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->

<script src="/js/script.js"></script>
  </body>
</html>